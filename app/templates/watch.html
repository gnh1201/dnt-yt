<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YT Cache Player ¬∑ {{ video_id }}</title>

  <style>
  {% raw %}
  :root {
    --bg: #0b1020;
    --panel: rgba(255,255,255,0.06);
    --stroke: rgba(255,255,255,0.12);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.65);
    --good: #3ddc97;
    --warn: #f7c948;
    --bad: #ff5c7a;
    --radius: 18px;
    --shadow: 0 18px 60px rgba(0,0,0,0.45);
    --btn: rgba(255,255,255,0.10);
    --btn-hover: rgba(255,255,255,0.16);
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color: var(--text);
    background:
      radial-gradient(1000px 600px at 20% 10%, rgba(61,220,151,0.10), transparent 60%),
      radial-gradient(900px 520px at 80% 0%, rgba(93,162,255,0.12), transparent 60%),
      radial-gradient(700px 520px at 60% 100%, rgba(255,92,122,0.10), transparent 60%),
      var(--bg);
  }

  .wrap {
    max-width: 980px;
    margin: 0 auto;
    padding: 28px 18px 48px;
  }

  .topbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 14px;
  }

  .pill {
    padding: 7px 10px;
    border-radius: 999px;
    background: var(--panel);
    border: 1px solid var(--stroke);
    font-size: 12px;
    color: var(--muted);
    max-width: 70vw;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 999px;
    background: var(--panel);
    border: 1px solid var(--stroke);
    font-size: 12px;
    color: var(--muted);
  }

  .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--warn);
  }
  .dot.good { background: var(--good); }
  .dot.bad  { background: var(--bad); }

  .card {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow: hidden;
  }

  .player {
    position: relative;
    background: #000;
    aspect-ratio: 16 / 9;
  }

  video {
    width: 100%;
    height: 100%;
    display: block;
    background: #000;
  }

  /* ===== Waiting Overlay ===== */

  .waiting {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    color: #fff;
    overflow: hidden;
    z-index: 3;
  }

  /* Thumbnail background (soft blur, brighter) */
  .waiting::before {
    content: "";
    position: absolute;
    inset: -12px;
    background-image: var(--thumb-url);
    background-position: center;
    background-size: cover;
    background-repeat: no-repeat;
    filter: blur(8px);
    transform: scale(1.04);
    opacity: 0.88;
  }

  /* Light vignette + subtle dark overlay */
  .waiting::after {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(
        ellipse at center,
        rgba(0,0,0,0.10),
        rgba(0,0,0,0.28)
      ),
      linear-gradient(
        180deg,
        rgba(0,0,0,0.18),
        rgba(0,0,0,0.28)
      );
  }

  .waiting-inner {
    position: relative;
    z-index: 1;
    text-align: center;
  }

  /* Glass message box */
  .glass {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 16px 18px;
    border-radius: 16px;
    background: rgba(255,255,255,0.16);
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
  }

  .spinner {
    width: 36px;
    height: 36px;
    border: 4px solid rgba(255,255,255,0.30);
    border-top-color: rgba(255,255,255,0.95);
    border-radius: 50%;
    animation: spin 0.9s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .controls {
    padding: 14px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    background: rgba(255,255,255,0.04);
  }

  .btns {
    display: inline-flex;
    gap: 8px;
  }

  button {
    border: 1px solid rgba(255,255,255,0.14);
    background: var(--btn);
    color: var(--text);
    border-radius: 12px;
    padding: 10px 14px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
  }

  button:hover { background: var(--btn-hover); }
  button.secondary { background: transparent; }

  {% endraw %}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="pill">video_id: {{ video_id }}</div>
      <div class="badge">
        <span class="dot" id="dot"></span>
        <span id="badgeText">Checking cache‚Ä¶</span>
      </div>
    </div>

    <div class="card">
      <div class="player">
        <video id="video" controls playsinline preload="auto" style="display:none"></video>

        <div class="waiting" id="waiting">
          <div class="waiting-inner">
            <div class="glass">
              <div class="spinner"></div>
              <div id="statusLine">Preparing cache‚Ä¶</div>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="btns">
          <button id="btnPlay">‚ñ∂ Play</button>
          <button class="secondary" id="btnPause">‚è∏ Pause</button>
          <button class="secondary" id="btnMute">üîá Muted</button>
        </div>
        <div class="pill" id="statusRight">status: initializing</div>
      </div>
    </div>

    <audio id="audio" preload="auto"></audio>
  </div>

  <script>
    const VIDEO_ID = {{ video_id | tojson }};
  </script>

  <script>
  {% raw %}
  const POLL_MS = 5000;
  const DRIFT = 0.25;

  const v = document.getElementById("video");
  const a = document.getElementById("audio");
  const waiting = document.getElementById("waiting");

  // We'll enable controls after we attach tracks (subtitles)
  v.controls = false;

  function applyWaitingThumbnail() {
    try {
      var thumbUrl = "/media/" + encodeURIComponent(VIDEO_ID) + "/thumbnail";
      var img = new Image();
      img.onload = function () {
        waiting.style.setProperty("--thumb-url", 'url("' + thumbUrl + '")');
      };
      img.onerror = function () {
        waiting.style.setProperty("--thumb-url", 'url("' + thumbUrl + '")');
      };
      img.src = thumbUrl;
    } catch {}
  }

  const statusLine = document.getElementById("statusLine");
  const statusRight = document.getElementById("statusRight");
  const badgeText = document.getElementById("badgeText");
  const dot = document.getElementById("dot");

  const btnPlay = document.getElementById("btnPlay");
  const btnPause = document.getElementById("btnPause");
  const btnMute = document.getElementById("btnMute");

  let ready = false;
  let timer = null;
  let audioEnabled = false;
  let subtitlesAttached = false;

  function setStatus(s) {
    statusRight.textContent = "status: " + s;
  }

  function setBadge(text, ok=false) {
    badgeText.textContent = text;
    dot.classList.toggle("good", ok);
  }

  function updateMuteButton() {
    btnMute.textContent = audioEnabled ? "üîä Unmuted" : "üîá Muted";
    btnMute.classList.toggle("secondary", !audioEnabled);
  }

  async function fetchStatus() {
    const r = await fetch(`/v1/yt/status?video_id=${encodeURIComponent(VIDEO_ID)}`);
    return await r.json();
  }

  function attach(vu, au) {
    if (v.src !== vu) v.src = vu;
    if (a.src !== au) a.src = au;
  }

  function sync() {
    if (!audioEnabled) return;
    if (Math.abs(v.currentTime - a.currentTime) > DRIFT) {
      a.currentTime = v.currentTime;
    }
  }

  function clearTracks() {
    try {
      var tracks = v.querySelectorAll("track");
      for (var i = 0; i < tracks.length; i++) tracks[i].remove();
    } catch {}
  }

  async function attachSubtitlesOnce() {
    if (subtitlesAttached) return;
    subtitlesAttached = true;

    clearTracks();

    // List available subtitle languages (expects JSON: { subtitles: ["en","ko", ...] })
    var langs = [];
    try {
      var r = await fetch("/media/" + encodeURIComponent(VIDEO_ID) + "/subtitles");
      if (r && r.ok) {
        var data = await r.json();
        if (data && data.subtitles && data.subtitles.length) langs = data.subtitles;
      }
    } catch {}

    if (!langs || !langs.length) {
      // Still enable controls even if there are no subtitles
      v.controls = true;
      return;
    }

    // Add <track> elements BEFORE enabling controls (CC menu stability)
    for (var j = 0; j < langs.length; j++) {
      var lang = langs[j];
      var t = document.createElement("track");
      t.kind = "subtitles";
      t.srclang = lang;
      t.label = lang;
      t.src = "/media/" + encodeURIComponent(VIDEO_ID) + "/subtitles/" + encodeURIComponent(lang);
      v.appendChild(t);
    }

    // Enable native controls after tracks are present
    v.controls = true;

    // Choose a default track (ko -> en -> first)
    function pickDefault() {
      try {
        if (!v.textTracks || !v.textTracks.length) return;

        // disable all
        for (var i = 0; i < v.textTracks.length; i++) v.textTracks[i].mode = "disabled";

        var preferred = null;
        for (var k = 0; k < langs.length; k++) if (langs[k] === "ko") preferred = "ko";
        if (!preferred) for (var k2 = 0; k2 < langs.length; k2++) if (langs[k2] === "en") preferred = "en";
        if (!preferred) preferred = langs[0];

        for (var i2 = 0; i2 < v.textTracks.length; i2++) {
          var tt = v.textTracks[i2];
          if (tt && tt.language === preferred) {
            tt.mode = "showing";
            break;
          }
        }
      } catch {}
    }

    v.addEventListener("loadedmetadata", pickDefault, { once: true });
    setTimeout(pickDefault, 150);
  }

  async function checkOnce() {
    const s = await fetchStatus();
    if (s && s.ready) {
      ready = true;
      attach(s.video_url, s.audio_url);

      // Attach subtitles before showing the video/controls
      await attachSubtitlesOnce();

      waiting.style.display = "none";
      v.style.display = "block";
      setBadge("Cache ready", true);
      setStatus("ready");

      try { await v.play(); } catch {}
      return true;
    }
    setStatus("waiting");
    return false;
  }

  btnPlay.onclick = async () => { if (ready) await v.play(); };
  btnPause.onclick = () => { v.pause(); try { a.pause(); } catch {} };
  btnMute.onclick = async () => {
    audioEnabled = !audioEnabled;
    updateMuteButton();
    if (audioEnabled) {
      a.currentTime = v.currentTime;
      try { await a.play(); } catch {}
    } else {
      try { a.pause(); } catch {}
    }
  };

  v.addEventListener("timeupdate", sync);
  v.addEventListener("seeking", () => {
    if (audioEnabled) a.currentTime = v.currentTime;
  });

  (async () => {
    updateMuteButton();
    applyWaitingThumbnail();
    await checkOnce();
    timer = setInterval(async () => {
      if (await checkOnce()) clearInterval(timer);
    }, POLL_MS);
  })();
  {% endraw %}
  </script>
</body>
</html>
